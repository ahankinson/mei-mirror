<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet version="2.0" xmlns:rng="http://relaxng.org/ns/structure/1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
  xmlns:db="http://docbook.org/ns/docbook"
  xmlns:tei="http://www.tei-c.org/ns/1.0" xmlns="http://www.tei-c.org/ns/1.0"
  exclude-result-prefixes="#all">

  <xsl:output method="xml" indent="yes" encoding="UTF-8"
    omit-xml-declaration="no" standalone="no"/>

  <xsl:strip-space elements="*"/>

  <xsl:variable name="nl">
    <xsl:text>&#xa;</xsl:text>
  </xsl:variable>

  <xsl:variable name="progname">
    <xsl:text>meiDocBook2TEI.xsl</xsl:text>
  </xsl:variable>

  <xsl:variable name="progversion">
    <xsl:text>v. 0.1</xsl:text>
  </xsl:variable>

  <xsl:variable name="loremipsum">
    <xsl:text>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed
      do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim
      ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
      aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit
      in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
      Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
      officia deserunt mollit anim id est laborum.</xsl:text>
  </xsl:variable>

  <xsl:template match="/" exclude-result-prefixes="#all">
    <xsl:processing-instruction name="oxygen"
      >RNGSchema="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/teilite.rng"
      type="xml"</xsl:processing-instruction>
    <TEI>
      <teiHeader>
        <fileDesc>
          <titleStmt>
            <title>MEI Tag Library</title>
          </titleStmt>
          <publicationStmt>
            <p>Charlottesville and Detmold, 2010</p>
          </publicationStmt>
          <sourceDesc>
            <p>
              <xsl:value-of
                select="concat('Born digital; generated by ', $progname,', ', $progversion, ', ',
                format-dateTime(current-dateTime(), '[Y]-[M01]-[D01]-[H01]:[m01]:[s01]'))"
              />
            </p>
          </sourceDesc>
        </fileDesc>
      </teiHeader>
      <text>
        <front>
          <titlePage>
            <docTitle>
              <titlePart>Music Encoding Initiative Tag Library</titlePart>
            </docTitle>
            <docEdition>2010-05 Release</docEdition>
            <docEdition>MEI Technical Document No. 2</docEdition>
            <byline>Prepared and maintained by the Music Encoding Initiative
              Working Group</byline>
            <note>This project is supported jointly by the National Endowment
              for the Humanities and the Deutsche Forschungsgemeinschaft. Any
              views, findings, conclusions or recommendations expressed in this
              publication do not necessarily reflect those of the National
              Endowment for the Humanities or the Deutsche
              Forschungsgemeinschaft.</note>
          </titlePage>
          <div>
            <head>Acknowledgments</head>
            <p>Many institutions and individuals assisted in the preparation of
              this tag library and in the overall development of the Music
              Encoding Initiative (MEI) schema.</p>
            <p>Grateful acknowledgment is given to the following institutions
              for their generous contributions: the National Endowment for the
              Humanities (NEH) and the Deutsche Forschungsgemeinschaft (DFG) for
              their joint support of the MEI project; the Institute for Advanced
              Technology in the Humanities at the University of Virginia and the
              Hochschule für Musik in Detmold for graciously hosting the
              grant-funded meetings; the Musikwissenschaftliches Seminar
              Detmold/ Universität Paderborn; the Center for Computer-Assisted
              Research in the Humanities at Stanford University for permission
              to make use of their large collection of encoded music; the
              Akademie der Wissenschaften und der Literatur in Mainz; and the
              University of Virginia Library for providing an environment in
              which ... ;</p>
            <p>The following individuals have provided much-appreciated
              commitments of time and energy to the development of MEI: Johannes
              Kepper (Edirom, Detmold); Erin Mayhood (Music Library, University
              of Virginia); Stefan Morent (Department of Musicology, University
              of Tubingen); Laurent Pugin (McGill University, Montreal); Daniel
              Rowenstrunk (Edirom, Detmold); Craig Sapp (Center for
              Computer-Assisted Research in the Humanities, Stanford
              University); Eleanor Selfridge-Field (Center for Computer-Assisted
              Research in the Humanities, Stanford University); Christine
              Siegert (OPERA Project, Universitat Bayreuth); Joachim Veit,
              (Carl-Maria-von-Weber-Gesamtausgabe, Academy of Music, Detmold,
              and University of Paderborn); and Raffaele Viglianti (Kings
              College, London).</p>
            <p>Thanks to Bernhard R. Appel (Beethoven-Archiv und Verlag,
              Beethoven-Haus, Bonn); Donald Byrd (Indiana University); J.
              Stephen Downie (Graduate School of Library and Information
              Science, University of Illinois at Urbana-Champaign); Richard
              Freedman (Haverford College, PA); Oliver Huck (Universitat
              Hamburg); Fotis Jannidis (Institut fur Deutsche Philologie,
              Universitat Wurzburg); and Frans Wiering (Information and
              Computing Sciences Department, University of Utrecht) for
              providing expertise ...</p>
            <p>Also thanks to Syd Bauman, Sebastian Rahtz and Terry Catapano for
              their problem-solving assistance during the development of the RNG
              schema.</p>
            <p>A large debt of gratitude is owed to those early adopters who
              recognized the potential of MEI: Julian Dabbert, Axel Teich
              Geertinger, Johannes Kepper, Stefan Morent, Laurent Pugin, Craig
              Sapp, Christine Siegert, Raffaele Viglianti.</p>
            <p>Daniel Pitti (Institute for Advanced Technology in the
              Humanities, University of Virginia) deserves special recognition
              for ... </p>
            <p>Gabriele Buschmeier (Akademie der Wissenschaften und der
              Literatur, Mainz) ...</p>
            <p>Finally, thanks to you, dear reader, for your interest in
              MEI.</p>
          </div>
          <div>
            <head>Introduction</head>
            <p>The Music Encoding Initiative (MEI) schema is a set of rules for
              recording the intellectual and physical characteristics of music
              notation documents so that the information contained in them may
              be searched, retrieved, displayed, and exchanged in a predictable
              and platform-independent manner. The MEI rules are expressed in
              the form of a RelaxNG (RNG) schema. Because schemas are intended
              to be read chiefly by computers, they are often accompanied by
              documentation designed for human comprehension. This tag library,
              which is a comprehensive list of MEI elements, is one such piece
              of documentation. It is intended to serve as a reference tool for
              music encoders. Through the use of natural-language definitions
              and examples, it assists users of MEI in achieving effective and
              consistent markup. Despite translating XML and RNG terminology and
              concepts into more accessible language, the tag library is still a
              technical document that presupposes readers will possess a minimal
              understanding of XML and music notation. Novice encoders will need
              to supplement their use of the tag library by consulting MEI
              application guidelines, attending introductory MEI workshops and
              training classes, and referring to other information sources.</p>
            <p>As a natural-language translation of the MEI schema, the tag
              library conveys information about the three principal tasks
              accomplished by the schema. First, the schema breaks down the
              content of music notation documents into data fields or categories
              of information called "elements". All of these elements are named,
              define, and described in the MEI Tag Library. Second, the tag
              library identifies and defines attributes associated with those
              elements. Attributes are characteristics or properties that
              further refine the element. Last, and perhaps most importantly,
              the tag library expresses the schema structure by explaining the
              relationship between elements, specifying where the elements may
              be used and describing how they may be modified by attributes.
              While two of the basic purposes of MEI are to facilitate the
              searching and display of encoded music notation documents in an
              electronic environment, nothing in the tag library addresses their
              specific implementation. Searching and display are entirely
              dependent on software applications outside the scope of MEI.</p>
            <p>Throughout the tag library, coded examples augment the narrative
              explanations and help illustrate the role, relationship, and usage
              of elements and attributes. The MEI schema contains only a few
              required elements, the rest are optional. Therefore, the amount of
              markup desired will vary from one situation to another depending
              on intellectual, technical, and financial considerations. Creating
              encoded music notation documents for inclusion union databases may
              also result in tagging requirements that are separate from those
              dictated by the schema.</p>
            <p>The tag library is divided into five sections. It begins with an
              outline of MEI Design Principles. This is followed by an overview
              of the structure of a typical MEI instance and an explanation of
              terms and conventions used in the tag library. Element definitions
              comprise the fourth and largest section of the tag library, while
              an index by element name concludes the documentation.</p>
            <p>Suggestions for new elements or revised descriptions may be
              submitted to the MEI Working Group via the MEI discussion list at
              mei-l@lists.uni-paderborn.de.</p>
          </div>
          <div>
            <head>MEI Design Principles</head>
            <p>This section of the tag library defines principles and criteria
              for designing, developing, and maintaining an XML-based encoding
              scheme for music notation documents.</p>
            <list>
              <head>Definitions and Parameters</head>
              <item>A music notation document is one that contains music
                notation; that is, any one of a number of "visual analogues of
                musical sound, either as a record of sound heard or imagined, or
                as a set of visual instructions for performers."</item>
              <item>The encoding scheme permits both the creation of new music
                notation documents and the conversion of existing ones from
                print and other electronic formats. However, conversion of
                existing documents may require revisions in content or
                rearrangement of information.</item>
            </list>
            <list>
              <head>General Principles</head>
              <item>No prima facia distinction is made between a primary source
                of music notation, such as an autograph or published score, and
                a secondary source, such as a scholarly edition based on one or
                more primary sources. The tag set encompasses both, the encoder
                must choose the elements and attributes most appropriate in each
                case.</item>
              <item>As an encoded representation of one or more music notation
                documents, an MEI file may be employed as a surrogate for the
                original materials.</item>
              <item>Although the encoding scheme does not define or prescribe
                intellectual content for music notation documents, it does
                define content designation and is intended to be used with
                available data content standards. MEI identifies the essential
                data elements within music notation documents and establishes
                codes and conventions necessary for capturing and distinguishing
                information within those elements for future action or
                manipulation. While there are a few elements that ought to
                appear in any MEI document, various intellectual, technical, and
                economic factors influence the level of detail of analysis and
                encoding actually undertaken. Taking this into consideration,
                the encoding scheme is designed with a minimum of required
                elements and allows for progressively more detailed levels of
                description as desired.</item>
              <item>The encoding scheme preserves and enhances the current
                functionality of existing music notation documents. It permits
                identification of document structures and content that support
                description, navigation, analysis, and online and print
                presentation.</item>
              <item>The encoding scheme is intended to facilitate interchange
                between notational tools. It aims to assist in the creation of
                more effective and consistent encoding, encourage the creation
                of union databases of music notation documents, and permit the
                reuse of encoded data for multiple output purposes. It will also
                ensure that machine-readable music notation documents will
                outlive changing hardware and software environments because they
                are based on a platform-independent standard.</item>
            </list>
            <list>
              <head>Structural Features</head>
              <item>The encoding scheme is based on eXtensible Markup Language
                (XML), a text-based format for representing structured
                information. It is expressed as a RelaxNG (RNG) schema, referred
                to as the "Music Encoding Initiative" or "MEI" schema.</item>
              <item>Related or complementary standards, such as the Text
                Encoding Initiative (TEI) Guidelines for Electronic Text
                Encoding and Interchange, the Encoded Archival Description (EAD)
                DTD, MARC formats, existing notation encoding schemes, etc. have
                been consulted and employed as appropriate. The data model
                includes a header that is similar to the TEI header, and TEI and
                EAD naming conventions and tag structures have been used
                whenever feasible. With respect to metadata, MEI recognizes the
                inter-relationship between the metadata content found in the MEI
                header and that of catalog records, authority records, and
                finding aids, and it provides for the use of an encoding
                equivalency attribute for MEI elements corresponding fields in
                other metadata standards.</item>
              <item>The encoding standard consists of three parts: an
                RNG-compliant schema, a tag library containing definitions of
                the schema's elements and attributes as well as examples of tag
                use, and application guidelines.</item>
              <item>To ensure broad international and multi-repertoire
                application of MEI, exising musical terminology was used in
                building the data model where practical. In addition, a method
                for localization of the data model's names has been provided.
                Finally, extensive use of attributes in the schema permits the
                refinement of element meanings with specific geographic or
                temporal contexts.</item>
            </list>
            <list>
              <head>Control and Maintenance</head>
              <item>Control and maintenance of the schema and its documentation
                will be provided by a maintenance agency working in concert with
                the national and international music communities, assisted in an
                advisory capacity by other interested groups of users.</item>
            </list>
          </div>
          <div>
            <head>Overview of MEI Structure</head>
            <p>In most cases, an MEI file, like many other representations, has
              a "header + message" structure. This is a commonly-occurring
              structure because it effectively separates metadata and data. In
              MEI these two parts of the file are called meihead and music and
              are contained within an mei element.</p>
            <p>The meihead element contains metadata about the encoded data
              found in the music element. The header is modeled on the TEI
              teiHeader element and therefore has the same components as in TEI
              – filedesc, encodingdesc, profiledesc, and revisiondesc – plus an
              optional meiid element. The filedesc and meiid elements are
              required. Filedesc contains further sub-elements describing the
              electronic file itself and the sources from which it was drawn.
              The encodingdesc element documents the relationship between an
              electronic file and the source or sources from which it was
              derived. That is, it describes the purpose of the encoding and the
              methods used to create the file. A description of the
              non-bibliographic aspects of the creation of a work, that is, the
              languages and sub-languages used, the situation in which it was
              produced, e.g. the participants, setting, reception history, etc.,
              is provided for by the profiledesc element and its children. The
              revisiondesc element provides a place to encode the revision
              history for the electronic file.</p>
            <p>The music element of the MEI file contains the actual encoded
              content. MEI is agnostic regarding the definition of the term
              music – it is simply the thing being encoded. It can be a
              monophonic song or a complex symphony – the character of the work
              is encoded by the music element's components. The underlying
              assumption, however, is that the work being encoded is or can be
              expressed in a notated form. A musical work in MEI terms may be a
              collection of works, such as a printed collected edition or an
              electronic database of related works.</p>
            <p>The music element allows front, body, and back components.
              Critical editions and collections of works often contain extensive
              text, such as a table of contents, an introduction, commentary, a
              biography, an index, etc. Accommodating this text within MEI gives
              control of the text as well as the notation markup to the encoder
              of the MEI instance and to the music markup community rather than
              the creators and maintainers of the text standard. In addition to
              front and back matter, MEI can also encode the introductory or
              explanatory text sometimes found between sections of a musical
              work.</p>
            <p>The body element encodes the musical content of the work. It
              contains one or more discrete, linear segments, called mdiv
              (“musical division”). An mdiv is the highest-level indication of
              the structure of the composition. For example, a single mdiv
              indicates a single-movement work; however, when a musical work can
              be broken into several top-level segments, the body element may
              contain multiple mdiv elements. The mdiv element is a generic one
              which may be typed – a symphony, for example, usually consists of
              movements while operas are made up of acts. A part or score may be
              divided into linear segments or sections. Section elements often
              function as a scoping mechanism for clef signs, key and meter
              signatures, plus metronome, tempo, and expression markings. Their
              use also minimizes the need for backward scanning to establish
              context when the starting point for access is not at the beginning
              of the score. Section elements may also be used for other
              user-defined, i.e., analytical or editorial, purposes, and
              arbitrarily nested to any desired level. There is also an ending
              element, a specialized instance of section element that may not be
              recursively nested.</p>
            <p>When the facsimile module is activated, the facsimile element is
              also allowed within music. Facsimile contains a representation of
              a written source in the form of a set of images rather than as
              transcribed text. Multiple facsimile elements may be used when
              multiple sets of images are needed, for example, when there are
              multiple sources. Within facsimile image files may be referenced
              using graphic elements and bounding boxes of areas of interest
              within the image may be indicated through the use of zone
              elements. Elements that mark semantic content may be linked to
              particular images or zones using the facs attribute, which is
              available when the facsimile module is activated.</p>
            <p>An mdiv element may contain one or both of two possible views.
              The score element contains a traditional, full open score while
              the parts element contains each performer’s view of the work.
              Score and parts views are intended to accommodate different
              methods of organizing the markup – no particular presentation is
              implied, and software may render a collection of parts as a score
              or a score as a collection of parts. The explicit encoding of two
              views is necessary because it is not always possible to
              automatically derive one view from the other. In addition,
              separating scores and parts can eliminate a great deal of markup
              complexity.</p>
            <p>A part element contains an individual performer’s view of the
              score, effectively a mini-score requiring all the encoding
              features of a full score. The encoding of individual parts is
              practical when they do not share visual characteristics, such as
              typeface or page layout, with the full score. Part elements in MEI
              have little to do with voice leading, which can be encoded using
              the next attribute available on all event-type elements.</p>
            <p>In both score and part views, the scoredef element and its
              sub-elements are used to describe logical characteristics of the
              encoded music, such as key signature, the "actual" key (as opposed
              to the notated key signature), meter, etc. and visual features,
              such as page size, staff groupings and labels, etc.</p>
            <p>Depending upon the time period of the notation and the encoder's
              needs, multiple methods of organization are possible in section
              elements. When the CMN module is "switched on", measure-by-measure
              encoding is allowed, with staff sub-elements within measure.
              However, when the mensural or neumes module is enabled,
              staff-by-staff organization is expected, a historically
              appropriate approach for these notation styles which do not have
              measures. In any case, layer sub-elements are expected within
              staff. Note that it is possible to use both of these organization
              methods simultaneously by enabling more than one of the CMN,
              mensural, or neumes modules; however, this is considered an
              advanced topic and is not covered in this introduction.</p>
            <p>It is important to note that within the layer element, semantic
              events, not visual symbols, are modeled. Events are the typical,
              time-based, discrete atoms of musical data, such as notes, chords,
              rests, etc. While events may have visual properties, modeling
              symbols places too much emphasis on presentational qualities and
              makes the markup less generally useful as a generic “music” markup
              standard.</p>
            <p>So-called "control events", such as dynamics, ties, phrase marks,
              pedal marks, etc., depend upon other events, such as notes or
              rests, for their existence. They often do not fit the principal
              hierarchy of sections, measures and staves. Neither can they
              always be treated as properties of other events. Therefore, a
              second class of events exists in MEI for these musical
              elements.</p>
            <p>Additional document elements, sometimes erroneously called "root"
              elements, may be employed in addition to the mei element. The
              meicorpus element can be employed to create a single file that
              contains multiple MEI instances or the meihead element can be used
              to create a "stand-alone" header; that is, an MEI instance that
              transmits only metadata without any accompanying music notation
              markup. Conversely, the music element may serve as the document
              element for a file that is expected to be inserted into another
              XML document, a TEI (Text Encoding Initiative) file for example,
              that already provides a context for the included material.</p>
          </div>
          <div>
            <head>Tag Library Conventions</head>
            <p>The "MEI Elements" section of the tag library contains
              descriptions of 238 elements, arranged alphabetically by their tag
              names. The "Index by Element Name" section makes it possible to
              locate those elements with tag names that might be hard to find
              alphabetically. For example, the index entry "bowed tremolo"
              points to the tag name "&lt;btrem&gt;". The index also
              serves as a concise, easily browsable list of all MEI
              elements.</p>
            <p>The "MEI Elements" section presents information for each element
              as shown in Figure 1.</p>
            <p>
              <figure>
                <head>Figure 1</head>
              </figure>
            </p>
            <p>Tag Name: Short, nmemonic form of the element name that is used
              in the machine-readable XML document. The tag name is the first
              word at the top of the entry. Tag names appear between angle
              brackets, e.g., &lt;mei&gt;, except in the listings under
              "May contain" and "May occur within". They are always in lower
              case.</p>
            <p>Element Name: Expanded version of the tag name that more fully
              describes the element's meaning. The full name of the element is
              usually a word or phrase that identifies the element's purpose. In
              the tag library, the element name follows the tag name.</p>
            <p>Description: Definition of the element typically drawn from
              standard reference works, glossaries, basic dictionaries, and data
              dictionaries, such as Gardner Read's Music Notation: A Manual of
              Modern Practice, Grove Music Online, Carl Parrish's Notation of
              Medieval Music, the Text Encoding Initiative Guidelines, the
              Encoded Archival Description Tag Library, etc. Additional text
              describes how the element is used, differentiates it from similar
              elements, points out useful attributes, provides an illustrative
              example, or directs the reader to related elements.</p>
            <p>May contain: Identifies other elements that may occur within the
              element being defined. Elements may be empty (e.g., permit no
              element content); or they may contain text (called PCDATA), other
              elements, or a mixture of text and elements. The abbreviation
              PCDATA (parsed character data) indicates that text content is
              allowed directly inside the element, but the text cannot include
              characters, such as left angle brackets, that might be interpreted
              by an XML parser as action codes. The list of permitted elements
              usually includes more elements than are generally needed because
              similar elements share the same content model. This practice eases
              the task of authoring a schema and aids machine processing of
              encoded documents.</p>
            <p>May occur within: Identifies all the elements within which the
              described element may appear. This information conveys the sense
              of where and how often an element is available throughout the
              schema. Definitions of parent elements may provide additional
              information about an element's usage.</p>
            <p>Attributes: Identifies all attributes associated with the
              element. Each entry in the list of attributes contains the
              attribute name, an indication of whether the attribute is optional
              or required, and the datatype to which a value is expected to
              conform.</p>
            <p>Module name: Identifies the schema module in which the element is
              defined. In order to use the element, this module must be
              activated.</p>
          </div>
        </front>
        <body>
          <div type="chapter">
            <head>MEI Elements</head>
            <xsl:apply-templates
              select="//db:sect2[db:title='Elements']/db:sect3"
              exclude-result-prefixes="#all" mode="elements">
              <xsl:sort select="db:title"/>
            </xsl:apply-templates>
          </div>
          <div type="chapter">
            <head>MEI Attributes</head>
            <xsl:for-each
              select="//db:sect3[matches(normalize-space(db:title),'^Attribute .*@.*$')]">
              <xsl:sort
                select="substring-after(normalize-space(db:title/db:literal), '@')"/>
              <div type="attribute" xml:id="{@xml:id}">
                <head>
                  <xsl:value-of
                    select="substring-after(db:title/db:literal, '@')"/>
                </head>
                <div type="desc">
                  <head>Description:</head>
                  <p>
                    <xsl:value-of
                      select="normalize-space(db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Annotations ']/db:entry[2])"
                    />
                  </p>
                </div>
                <div type="usedby">
                  <head>Used by:</head>
                  <p>
                    <xsl:variable name="usedby">
                      <xsl:choose>
                        <xsl:when
                          test="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Used by ']">
                          <xsl:for-each
                            select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Used by ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry='Element ' or db:entry='Elements ']">
                            <xsl:for-each select="db:entry[2]/db:link">
                              <ref target="#{@linkend}">
                                <xsl:value-of select="."/>
                              </ref>
                            </xsl:for-each>
                          </xsl:for-each>
                          <xsl:for-each
                            select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Used by ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry='Attribute Group ' or db:entry='Attribute Groups ']/db:entry[2]/db:link">
                            <xsl:variable name="linkend">
                              <xsl:value-of select="@linkend"/>
                            </xsl:variable>
                            <xsl:apply-templates
                              select="//db:sect3[@xml:id=$linkend]"
                              mode="usedByAttr"/>
                          </xsl:for-each>
                        </xsl:when>
                        <xsl:otherwise>
                          <xsl:variable name="thisattr">
                            <xsl:value-of select="@xml:id"/>
                          </xsl:variable>

                          <xsl:for-each
                            select="//db:sect3[starts-with(db:title, 'Element')
                            and descendant::db:row[db:entry=' Attributes ']//db:emphasis[@linkend=$thisattr]]">
                            <ref target="#{@xml:id}">
                              <xsl:value-of select="db:title/db:literal"/>
                            </ref>
                          </xsl:for-each>

                        </xsl:otherwise>
                      </xsl:choose>
                    </xsl:variable>
                    <xsl:for-each select="$usedby/tei:ref">
                      <xsl:sort select="."/>
                      <xsl:copy-of select="."/>
                      <xsl:if test="position() != last()">
                        <xsl:text>, </xsl:text>
                      </xsl:if>
                    </xsl:for-each>
                  </p>
                </div>
                <div type="module">
                  <head>Module:</head>
                  <p>
                    <xsl:variable name="module">
                      <xsl:value-of
                        select="replace(replace(replace(normalize-space(db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Schema location ']/db:entry[2]), '.*/', ''), '_.*', ''), '\.xsd$', '')"
                      />
                    </xsl:variable>
                    <xsl:choose>
                      <xsl:when test="$module = 'xml' or $module = 'xlink'">
                        <xsl:text>shared</xsl:text>
                      </xsl:when>
                      <xsl:otherwise>
                        <xsl:value-of select="$module"/>
                      </xsl:otherwise>
                    </xsl:choose>
                  </p>
                </div>
              </div>
            </xsl:for-each>
          </div>

          <!-- <div type="chapter">
            <head>MEI Datatypes</head>
            <xsl:apply-templates
              select="//db:sect2[db:title='Simple Types']/db:sect3"
              exclude-result-prefixes="#all" mode="simpletypes">
              <xsl:sort select="db:title"/>
            </xsl:apply-templates>
          </div> -->
          <!-- <div type="chapter">
            <head>MEI Attribute Groups</head>
            <xsl:apply-templates
              select="//db:sect2[db:title='Attribute Groups']/db:sect3[not(starts-with(db:title/db:literal, 'attlist\.'))]"
              exclude-result-prefixes="#all" mode="attGroup">
              <xsl:sort select="db:title"/>
            </xsl:apply-templates>
          </div> -->
          <!-- <div type="chapter">
            <head>MEI Element Groups</head>
            <xsl:apply-templates
              select="//db:sect2[db:title='Element Groups']/db:sect3"
              exclude-result-prefixes="#all" mode="elementgrps">
              <xsl:sort select="db:title"/>
            </xsl:apply-templates>
          </div> -->
        </body>
      </text>
    </TEI>
  </xsl:template>

  <xsl:template match="db:sect3" exclude-result-prefixes="#all" mode="elements">
    <div type="element" xml:id="{@xml:id}">
      <head>
        <xsl:variable name="head"> &lt;<xsl:value-of
            select="db:title/db:literal"/>&gt; <xsl:value-of
            select="substring-before(db:informaltable/db:tgroup/db:tbody/db:row[2]/db:entry[2]/db:para/db:programlisting,'―')"
          />
        </xsl:variable>
        <xsl:value-of select="normalize-space($head)"/>
      </head>
      <div type="desc">
        <head>Description:</head>
        <p>
          <xsl:value-of
            select="normalize-space(substring-after(db:informaltable/db:tgroup/db:tbody/db:row[2]/db:entry[2]/db:para/db:programlisting,'―'))"
          />
        </p>
      </div>
      <div type="content">
        <head>May contain:</head>
        <p>
          <xsl:variable name="contentRef">
            <xsl:value-of
              select="normalize-space(db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Type ']/db:entry[2]/db:link/@linkend)"
            />
          </xsl:variable>
          <xsl:variable name="maycontain">
            <xsl:for-each
              select="//db:sect3[@xml:id=$contentRef]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Children ']/db:entry[2]/db:link">
              <ref target="#{@linkend}">
                <xsl:value-of select="."/>
              </ref>
              <xsl:if test="position() != last()">
                <xsl:text>, </xsl:text>
              </xsl:if>
            </xsl:for-each>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="$maycontain=''">
              <xsl:text>EMPTY</xsl:text>
            </xsl:when>
            <xsl:otherwise>
              <xsl:variable name="mixed">
                <xsl:value-of
                  select="//db:sect3[@xml:id=$contentRef]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Properties ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry='mixed: ']/db:entry[2]"
                />
              </xsl:variable>
              <xsl:if test="$mixed != ''">
                <xsl:text>PCDATA, </xsl:text>
              </xsl:if>
              <xsl:copy-of select="$maycontain"/>
            </xsl:otherwise>
          </xsl:choose>
        </p>
      </div>
      <div type="usedby">
        <head>May occur within:</head>
        <p>
          <xsl:variable name="usedby">
            <xsl:for-each
              select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Used by ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry='Element ' or db:entry='Elements ']">
              <xsl:for-each select="db:entry[2]/db:link">
                <ref target="#{@linkend}">
                  <xsl:value-of select="."/>
                </ref>
              </xsl:for-each>
            </xsl:for-each>
            <xsl:for-each
              select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Used by ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry='Element Group ' or db:entry='Element Groups ']/db:entry[2]/db:link">
              <xsl:variable name="linkend">
                <xsl:value-of select="@linkend"/>
              </xsl:variable>
              <xsl:apply-templates select="//db:sect3[@xml:id=$linkend]"
                mode="usedBy"/>
            </xsl:for-each>
          </xsl:variable>
          <xsl:for-each select="$usedby/tei:ref">
            <xsl:sort select="."/>
            <xsl:copy-of select="."/>
            <xsl:if test="position() != last()">
              <xsl:text>, </xsl:text>
            </xsl:if>
          </xsl:for-each>
        </p>
      </div>
      <div type="attList">
        <head>Attributes:</head>
        <list>
          <xsl:for-each
            select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Attributes ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[count(db:entry)=5]">
            <xsl:sort select="db:entry[1]"/>
            <item>
              <xsl:choose>
                <xsl:when test="db:entry[1]//db:link">
                  <ref target="#{db:entry[1]//db:link/@linkend}">
                    <xsl:value-of select="db:entry[1]"/>
                  </ref>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="attrName">
                    <xsl:text>@</xsl:text>
                    <xsl:value-of select="normalize-space(db:entry[1])"/>
                  </xsl:variable>
                  <xsl:variable name="attrID">
                    <xsl:value-of
                      select="//db:sect3[contains(db:title, $attrName)]/@xml:id"
                    />
                  </xsl:variable>
                  <ref target="#{$attrID}">
                    <xsl:value-of select="db:entry[1]"/>
                  </ref>
                </xsl:otherwise>
              </xsl:choose>
              <xsl:text>, </xsl:text>
              <xsl:value-of select="db:entry[5]"/>
              <xsl:choose>
                <xsl:when test="db:entry[2] != ''">
                  <xsl:text>, </xsl:text>
                  <xsl:choose>
                    <xsl:when test="contains(db:entry[2], 'data.')">
                      <xsl:variable name="facetRef">
                        <xsl:value-of select="db:entry[2]/db:link/@linkend"/>
                      </xsl:variable>
                      <xsl:apply-templates
                        select="//db:sect3[@xml:id=$facetRef]" mode="facets"/>
                    </xsl:when>
                    <xsl:when test="contains(db:entry[2],'restriction of')">
                      <xsl:variable name="facetRef">
                        <xsl:value-of select="db:entry[1]//db:link/@linkend"/>
                      </xsl:variable>
                      <xsl:apply-templates
                        select="//db:sect3[@xml:id=$facetRef]" mode="facets"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:value-of select="db:entry[2]"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:choose>
                    <xsl:when test="db:entry[1] = 'xml:id'">
                      <xsl:text>, xs:ID</xsl:text>
                    </xsl:when>
                    <xsl:when test="db:entry[1] = 'xml:lang'">
                      <xsl:text>, xs:language</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:text>, CDATA</xsl:text>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:otherwise>
              </xsl:choose>
              <!-- <lb/>
              <xsl:choose>
                <xsl:when test="db:entry[1] = 'xml:id'">
                  <xsl:value-of
                    select="normalize-space(//db:sect3[contains(db:title,'@xml:id')]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Annotations ']/db:entry[2]//db:programlisting)"
                  />
                </xsl:when>
                <xsl:when test="db:entry[1] = 'xml:lang'">
                  <xsl:value-of
                    select="normalize-space(//db:sect3[contains(db:title,'@xml:lang')]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Annotations ']/db:entry[2]//db:programlisting)"
                  />
                </xsl:when>
                <xsl:otherwise>
                  <xsl:value-of
                    select="normalize-space(following-sibling::db:row[1]/db:entry[1]/db:programlisting)"
                  />
                </xsl:otherwise>
              </xsl:choose> -->
            </item>
          </xsl:for-each>
        </list>
      </div>
      <div type="module">
        <head>Module:</head>
        <p>
          <xsl:variable name="module">
            <xsl:value-of
              select="replace(normalize-space(db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Schema location ']/db:entry[2]), '.*/', '')"
            />
          </xsl:variable>
          <xsl:value-of select="replace($module, '_.*', '')"/>
        </p>
      </div>
    </div>
  </xsl:template>

  <xsl:template match="db:sect3" exclude-result-prefixes="#all" mode="facets">
    <xsl:choose>
      <xsl:when
        test="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Type ']/db:entry[2]/db:link">
        <xsl:value-of
          select="replace(replace(replace(replace(normalize-space(db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Type ']/db:entry[2]), 'restriction of ', ''), 'union of', ''), '[\(\)]', ''), 'list of .*$', 'list of ')"/>
        <xsl:for-each
          select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Type ']/db:entry[2]/db:link">
          <xsl:variable name="typeRef">
            <xsl:value-of select="@linkend"/>
          </xsl:variable>
          <xsl:apply-templates select="//db:sect3[@xml:id=$typeRef]"
            mode="facets"/>
          <xsl:if test="position() != last()">
            <xsl:text>, </xsl:text>
          </xsl:if>
        </xsl:for-each>
        <xsl:choose>
          <xsl:when
            test="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Facets ']">
            <xsl:text>, </xsl:text>
            <xsl:apply-templates
              select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Facets ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody"
              mode="facets"/>
          </xsl:when>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of
          select="replace(replace(replace(normalize-space(db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Type ']/db:entry[2]), 'restriction of ', ''), 'union of', ''), '[\(\)]', '')"/>
        <xsl:choose>
          <xsl:when
            test="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Facets ']">
            <xsl:text>, </xsl:text>
            <xsl:apply-templates
              select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Facets ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody"
              mode="facets"/>
          </xsl:when>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="db:tbody" mode="facets">
    <xsl:choose>
      <xsl:when
        test="db:row[db:entry='minInclusive'] or
        db:row[db:entry='maxInclusive']">
        <xsl:variable name="min">
          <xsl:value-of select="db:row[db:entry='minInclusive']/db:entry[2]"/>
        </xsl:variable>
        <xsl:variable name="max">
          <xsl:value-of select="db:row[db:entry='maxInclusive']/db:entry[2]"/>
        </xsl:variable>
        <xsl:text> </xsl:text>
        <xsl:choose>
          <xsl:when test="$min = ''">
            <xsl:if
              test="contains(ancestor::db:sect3/db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Type ']/db:entry[2], 'decimal')">
              <xsl:text>-&#x221e;</xsl:text>
            </xsl:if>
            <xsl:if
              test="contains(ancestor::db:sect3/db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Type ']/db:entry[2], 'Integer')">
              <xsl:text>0</xsl:text>
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$min"/>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:text> - </xsl:text>
        <xsl:choose>
          <xsl:when test="$max = ''">
            <xsl:if
              test="contains(ancestor::db:sect3/db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Type ']/db:entry[2], 'decimal')">
              <xsl:text>&#x221e;</xsl:text>
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$max"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:for-each select="db:row">
          <xsl:choose>
            <xsl:when test="db:entry[1] = 'pattern'">
              <xsl:text>"</xsl:text>
              <xsl:value-of select="normalize-space(db:entry[2])"/>
              <xsl:text>"</xsl:text>
            </xsl:when>
            <xsl:when test="db:entry[1] = 'minLength'">
              <xsl:text> minimum length of </xsl:text>
              <xsl:value-of select="normalize-space(db:entry[2])"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="normalize-space(db:entry[2])"/>
            </xsl:otherwise>
          </xsl:choose>
          <xsl:if test="position() != last()">
            <xsl:text>, </xsl:text>
          </xsl:if>
        </xsl:for-each>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="db:sect3" exclude-result-prefixes="#all" mode="usedBy">
    <xsl:for-each
      select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Used by ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry='Element ' or db:entry='Elements ']">
      <xsl:for-each select="db:entry[2]/db:link">
        <ref target="#{@linkend}">
          <xsl:value-of select="."/>
        </ref>
      </xsl:for-each>
    </xsl:for-each>
    <xsl:for-each
      select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Used by ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry='Element Group ' or db:entry='Element Groups ']/db:entry[2]/db:link">
      <xsl:variable name="linkend">
        <xsl:value-of select="@linkend"/>
      </xsl:variable>
      <xsl:apply-templates select="//db:sect3[@xml:id=$linkend]" mode="usedBy"/>
    </xsl:for-each>
  </xsl:template>

  <xsl:template match="db:sect3" exclude-result-prefixes="#all"
    mode="usedByAttr">
    <xsl:for-each
      select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Used by ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry='Element ' or db:entry='Elements ']">
      <xsl:for-each select="db:entry[2]/db:link">
        <ref target="#{@linkend}">
          <xsl:value-of select="."/>
        </ref>
      </xsl:for-each>
    </xsl:for-each>
    <xsl:for-each
      select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Used by ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[db:entry='Attribute Group ' or db:entry='Attribute Groups ']/db:entry[2]/db:link">
      <xsl:variable name="linkend">
        <xsl:value-of select="@linkend"/>
      </xsl:variable>
      <xsl:apply-templates select="//db:sect3[@xml:id=$linkend]"
        mode="usedByAttr"/>
    </xsl:for-each>
  </xsl:template>

  <xsl:template match="db:sect3" mode="attributes">
    <div type="attribute" xml:id="{@xml:id}">
      <head>
        <xsl:value-of select="substring-after(db:title/db:literal, '@')"/>
      </head>
      <p>
        <xsl:value-of
          select="normalize-space(db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Annotations ']/db:entry[2])"
        />
      </p>
    </div>
  </xsl:template>

  <xsl:template match="db:sect3" exclude-result-prefixes="#all"
    mode="elementgrps">
    <div type="elementGroup" xml:id="{@xml:id}">
      <head>
        <xsl:value-of select="db:title/db:literal"/>
      </head>
      <div type="Members">
        <head>Members:</head>
        <p>
          <xsl:for-each
            select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Children ']/db:entry[2]/db:link">
            <ref target="#{@linkend}">
              <xsl:value-of select="."/>
            </ref>
            <xsl:if test="position() != last()">
              <xsl:text>, </xsl:text>
            </xsl:if>
          </xsl:for-each>
        </p>
      </div>
      <div type="usedby">
        <head>Used by:</head>
        <p>
          <xsl:for-each
            select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Used by ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[not(db:entry='Complex Type ' or db:entry='Complex Types ')]/db:entry[2]/db:link">
            <xsl:sort select="."/>
            <ref target="#{@linkend}">
              <xsl:value-of select="."/>
            </ref>
            <xsl:if test="position() != last()">
              <xsl:text>, </xsl:text>
            </xsl:if>
          </xsl:for-each>
        </p>
      </div>
    </div>
  </xsl:template>

  <xsl:template match="db:sect3" exclude-result-prefixes="#all"
    mode="simpletypes">
    <div type="simpleType" xml:id="{@xml:id}">
      <head>
        <xsl:value-of select="db:title/db:literal"/>
      </head>
      <p>
        <xsl:value-of
          select="concat('Description: ',normalize-space(db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Annotations ']/db:entry[2]))"
        />
      </p>
      <xsl:variable name="enum">
        <xsl:value-of
          select="normalize-space(db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Type ']/db:entry[2])"
        />
      </xsl:variable>
      <xsl:choose>
        <xsl:when
          test="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Facets ']">
          <xsl:apply-templates
            select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Facets ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody"
            mode="facets">
            <xsl:with-param name="listhead">
              <xsl:value-of select="$enum"/>
            </xsl:with-param>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <p>
            <xsl:value-of select="$enum"/>
          </p>
        </xsl:otherwise>
      </xsl:choose>
    </div>
  </xsl:template>

  <xsl:template match="db:sect3" exclude-result-prefixes="#all" mode="attGroup">
    <xsl:if test="not(starts-with(db:title/db:literal, 'attlist')) ">
      <div type="attGroup" xml:id="{@xml:id}">
        <head>
          <xsl:value-of select="db:title/db:literal"/>
        </head>
        <list>
          <xsl:for-each
            select="db:informaltable/db:tgroup/db:tbody/db:row[db:entry=' Attributes ']/db:entry[2]/db:informaltable/db:tgroup/db:tbody/db:row[count(db:entry)=5]">
            <xsl:sort select="db:entry[1]"/>
            <item>
              <xsl:value-of select="db:entry[1]"/>
              <lb/>
              <xsl:value-of
                select="normalize-space(following-sibling::db:row[1]/db:entry[1]/db:programlisting)"/>
              <xsl:choose>
                <xsl:when test="db:entry[2] != ''">
                  <xsl:text>, </xsl:text>
                  <xsl:value-of
                    select="translate(replace(db:entry[2], 'xs:', ''), 'abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')"
                  />
                </xsl:when>
                <xsl:otherwise>
                  <xsl:choose>
                    <xsl:when test="db:entry[1] = 'id'">
                      <xsl:text>, ID</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:text>, CDATA</xsl:text>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:otherwise>
              </xsl:choose>
              <xsl:value-of select="db:entry[5]"/>
            </item>
          </xsl:for-each>
        </list>
      </div>
    </xsl:if>
  </xsl:template>

</xsl:stylesheet>
